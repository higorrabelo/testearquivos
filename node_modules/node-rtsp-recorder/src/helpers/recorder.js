//
//  recorder.js
//  node-rtsp-recorder
//
//  Created by Sahil Chaddha on 24/08/2018.
//  Edited by Deivid Oliveira on 17/06/2019.
//

const moment = require('moment')
const childProcess = require('child_process')
const path = require('path')
const FileHandler = require('./fileHandler')

const fh = new FileHandler()

var RTSPRecorder = function(config){
  this.config = config
  this.equipment = config.equipment
  this.camera = config.camera
  this.url = config.url
  this.timeLimit = config.timeLimit || 60
  this.root = config.root || 'media/'
  this.categoryType = config.type || 'video'
  this.directoryPathFormat = config.directoryPathFormat || 'DD-MM-YYYY'
  this.fileNameFormat = config.fileNameFormat || 'YYYY-MM-DD-h-mm-ss'
  // fh.createDirIfNotExists(this.getDirectoryPath())
  // fh.createDirIfNotExists(this.getTodayPath())
}

RTSPRecorder.prototype = {
  
  getDirectoryPath: function() {
    return path.join(this.root, (this.equipment ? this.equipment : ''), (this.camera ? this.camera : ''))
  },
  
  getTodayPath: function() {
    // return path.join(this.getDirectoryPath(), moment().format(this.directoryPathFormat))
    return path.join(this.root, moment().format(this.directoryPathFormat), (this.equipment ? this.equipment : ''), (this.camera ? this.camera : '') )
  },

  getMediaTypePath: function() {
    return path.join(this.getTodayPath(), this.categoryType)
  },

  getFilename: function(folderPath) {
    return path.join(folderPath, moment().format(this.fileNameFormat) + this.getExtenstion())
  },

  getPathWeb: function(filename) {
    console.log("filename "+filename)
    return filename.replace(path.join(this.root), '')
  },

  getExtenstion: function() {
    if (this.categoryType === 'audio') {
      return '.avi'
    }
    if (this.categoryType === 'image') {
      return '.jpg'
    }

    return '.mp4'
  },

  getArguments: function() {
    if (this.categoryType === 'audio') {
      return ['-vn', '-acodec', 'copy']
    }
    if (this.categoryType === 'image') {
      return ['-vframes', '1']
    }
    return ['-acodec', 'copy', '-vcodec', 'copy']
  },

  getChildProcess: function(fileName) {
    var args = ['-i', this.url]
    const mediaArgs = this.getArguments()
    mediaArgs.forEach((item) => {
      args.push(item)
    })
    args.push(fileName)
    return childProcess.spawn('ffmpeg',
      args,
      { detached: false, stdio: 'ignore' })
  },

  stopRecording: function() {
    this.disableStreaming = true
    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }
    if (this.writeStream) {
      this.killStream()
    }
  },

  startRecording: function() {
    if (!this.url) {
      console.log('URL Not Found.')
      return true
    }
    this.recordStream()
  },

  captureImage: function(dir, cb) {
    var self = this
    var writeStream = this.getChildProcess(dir)
    writeStream.once('exit', () => {})

    writeStream.once('close', (exitCode) => {
      if(cb && exitCode === 0){
        // console.log('captura realizada com sucesso')
        cb(false, dir)
      }else if(cb && exitCode === null){
        // console.log('captura não foi realizada')
        cb(true)
      }
    })

    setTimeout(function () {
      self.killStream(writeStream)
    }, 5000)
  },

  killStream: function(stream) {
    if(stream && !stream._closesGot){
      stream.kill()
      console.log('Killing stream')
    }else{
      console.log('A stream já havia sido terminada')
    }
  },

  recordStream: function() {
    if (this.categoryType === 'image') {
      return
    }
    const self = this
    if (this.timer) {
      clearTimeout(this.timer)
    }

    if (this.writeStream && this.writeStream.binded) {
      return false
    }

    if (this.writeStream && this.writeStream.connected) {
      this.writeStream.binded = true
      this.writeStream.once('exit', () => {
        self.recordStream()
      })
      this.killStream()
      return false
    }

    this.writeStream = null
    const folderPath = this.getMediaTypePath()
    fh.createDirIfNotExists(folderPath)
    const fileName = this.getFilename(folderPath)
    this.writeStream = this.getChildProcess(fileName)

    this.writeStream.once('exit', () => {
      if (self.disableStreaming) {
        return true
      }
      self.recordStream()
    })
    this.timer = setTimeout(self.killStream.bind(this), this.timeLimit * 1000)

    console.log('Start record ' + fileName)
  }
}

module.exports = RTSPRecorder
